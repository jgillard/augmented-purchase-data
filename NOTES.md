# Dev Notes

## Introduction
This repository / codebase will likely be pretty messy as I work. This is my first REST API, first Go project, first time developing with TDD, so I'm making a lot of mistakes (not following best practices) along the way. But that means I'm learning a lot! Here I'll write notes of what I'm discovering en-route.

## Notes
* The process of: write failing test, make it pass, refactor, is valuable and you have to be disciplined to stick to that. Right now I'm not doing well at producing commits that only refactor, or only add new tests; I'm trying to move too quickly which results in test changes & code changes muddled together. Having a clearer idea of the exact task that will go into the next commit will help, rather than making general improvements, or working in multiple improvements at once.
* Keep a groomed backlog of work. Prevents getting side-tracked by adding many small work items at the top of the queue, which do not need to happen right away. Also keep the long-term goals/tasks tracked for when an epic is completed so that the next can be started immediately.
* Have something working end-to-end relatively early, so that value is delivered and iteration adds immediate, usable value. At this point the project does not work end-to-end, and it's a large piece of work to make that happen. Would have been better to gave a working & tested server that I worked on alongside the unit tests. Part of the reason for not doing this was not knowing what datastore to use. DynamoDB On-Demand may now a good (cheap) fit for this, with the server "running" on Lambda. Or something like Heroku. Can use Github Actions for simple deployments.
* Avoid using an in-memory datastore for the unit tests as that itself needs testing. As I remove that from the test files now, it's obvious that the tests should all be using mocks/stubs/spies, and this datastore should have tests that are different from the business logic unit tests.
* The need for separation of concerns became apparent when adding an RPC interface. The HTTP handlers were somewhat coupled to the business logic, and needed a lot of time to unwind. Fortunately the unit tests made this safe, but it could have been anticipated earlier. Moving the http handlers into a separate package to the internal logic is the chosen method of arranging the code.